#+TITLE: Emacs AppImage Builder (Arch Linux Universal)
#+AUTHOR: Emacs AppImage Builder
#+OPTIONS: toc:nil num:nil

* Overview
This project provides a robust, automated build system to create a portable *GNU Emacs AppImage* using an Arch Linux base.

It uses *LinuxDeploy* to bundle dependencies while specifically excluding system-dependent GUI toolkits (GTK) to ensure seamless integration with host themes, fonts, and input methods.

** Key Features
- *Version:* Builds Emacs 30.2 (configurable).
- *Performance:* Compiled with =-O3 -march=native=, Native Compilation (AOT), and pure GTK3 (PGTK).
- *Modern Features:* Includes Tree-sitter, JSON, SVG, and Xwidgets (Webkit).
- *Native Look & Feel:* Uses the host system's GTK theme and fonts (fixes common AppImage UI ugliness).
- *Smart Dispatcher:* Acts as =emacs= or =emacsclient= depending on how it is invoked.
- *FUSE-Safe Building:* Build process runs entirely in userspace (extracts tools) to avoid Docker FUSE issues.

* Requirements
- *Docker* (Recommended method)
- *OR* An Arch Linux system with =base-devel= installed.

* Building (The Easy Way)
The recommended way to build is using the provided Docker wrapper. This handles all dependencies and FUSE permissions automatically.

#+begin_src sh
  # 1. Make scripts executable
  chmod +x docker-create-emacs-appimage.sh build-emacs-appimage.sh

  # 2. Run the builder
  ./docker-create-emacs-appimage.sh
#+end_src

** Build Options
You can pass arguments to the Docker wrapper:

#+begin_src sh
  # Build a specific version with a custom icon
  ./docker-create-emacs-appimage.sh \
      --version 31.0.50 \
      --icon "https://raw.githubusercontent.com/d12frosted/homebrew-emacs-plus/master/icons/modern-icon.png" \
      --output "Emacs-Next.AppImage"
#+end_src

* Usage
** Running Emacs
Simply execute the AppImage:
#+begin_src sh
  ./emacs-30.2-x86_64.AppImage
#+end_src

** Running Emacs Client
The AppImage contains a smart dispatcher. You can use ~emacsclient~ features in two ways:

*** Method 1: Symlink (Recommended)
Create a symlink named ~emacsclient~ pointing to the AppImage. The AppImage detects its name and switches mode automatically.

#+begin_src sh
  # Create the link
  ln -s ./emacs-30.2-x86_64.AppImage emacsclient

  # Run it (connects to the socket)
  ./emacsclient -c -a ""
#+end_src

*** Method 2: Direct Argument
Pass the command as the first argument to the AppImage.

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage emacsclient -c -a ""
#+end_src

* Technical Details
** How the Build Works
1. *Bootstrap:* Installs build dependencies (gcc, make, gtk3, webkit2gtk, etc.) via Pacman.
2. *Compilation:* Compiles Emacs from source with ~--with-native-compilation=aot~ and ~--with-pgtk~.
3. *Preparation:* Moves the ~emacs.pdmp~ (portable dumper) file to the correct architecture-specific directory.
4. *Bundling:*
   - Uses *LinuxDeploy* to crawl the binary and bundle required shared libraries (libpng, librsvg, libxml2, etc.).
   - *Excludes* GTK/GDK/GLib libraries via ~--exclude-library~. This strategy avoids the "Frankenstein" library issue where bundled GTK libs cannot find host system schemas, ensuring native UI integration.
5. *AppRun:* Injects a custom ~AppRun~ script that sets up environment variables (~EMACSLOADPATH~, ~EMACSDATA~) and handles the ~emacsclient~ dispatching.

** Troubleshooting
- *FUSE Errors:* If running on a system without FUSE, you can run the AppImage by extracting it:
  #+begin_src sh
    ./emacs-30.2-x86_64.AppImage --appimage-extract
    ./squashfs-root/AppRun
  #+end_src
- *Black Icon:* If the icon appears black/blank, the build script automatically generates a fallback SVG. Ensure your desktop environment supports SVG icons.

*** The Technical Difficulty with xwidget

You can think of the browser widget (xwidget) as an artist painting a picture, and Emacs as the gallery displaying it.

1. =WEBKIT_DISABLE_COMPOSITING_MODE=1= (The "Nuclear" Option)

    What happens: The browser stops using the GPU completely. The CPU has to calculate every pixel of the website, draw it, and then hand it to Emacs.

    Result: High stability, but Slow.

    Feel: Scrolling large pages might feel sluggish, and watching videos inside Emacs will consume 100% of a CPU core.

2. =WEBKIT_DISABLE_DMABUF_RENDERER=1= (The "Surgical" Option)

    What happens: The browser still uses your AMD GPU to render the website quickly.

    The Change: Normally, the browser tries to hand that finished image directly to Emacs via a fast hardware shortcut (DMABuf). This shortcut is what is crashing. By setting this flag, you force the browser to take a slightly slower route (copying the image to system memory first) to hand it over to Emacs.

    Result: Fast. The GPU still does the hard work; the only "slow" part is the hand-off, which is negligible on modern AMD cards.

    | Feature        | DISABLE_COMPOSITING_MODE    | DISABLE_DMABUF_RENDERER |
    |----------------+-----------------------------+-------------------------|
    | Page Rendering | CPU (Slow)                  | GPU (Fast)              |
    | Video Playback | Choppy / High CPU usage     | Smooth                  |
    | Crash Fix?     | Yes                         | Yes                     |
    | Recommended?   | Only if the other one fails | Yes                     |

 This need to be updated in =emacs.desktop=

* Credits & Inspiration
This project builds upon the hard work of the community. Special thanks to:

- [[https://github.com/blahgeek/emacs-appimage/][blahgeek/emacs-appimage]]: For the inspiration on Docker-based Arch build workflows.
- [[https://github.com/probonopd/Emacs.AppImage][probonopd/Emacs.AppImage]]: For pioneering the Emacs AppImage concepts and tooling.
