#+TITLE: Emacs AppImage Builder (Arch Linux Universal)
#+AUTHOR: Emacs AppImage Builder
#+OPTIONS: toc:nil num:nil

* Overview
This project provides a robust, automated build system to create a portable *GNU Emacs AppImage* using an Arch Linux base.

It uses *LinuxDeploy* to bundle dependencies while specifically excluding system-dependent GUI toolkits (GTK) to ensure seamless integration with host themes, fonts, and input methods.

** Testing & Compatibility
This build system has been tested and verified on Arch Linux with various desktop environments including GNOME, KDE Plasma, and XFCE. It supports multiple GPU configurations (AMD, Intel, NVIDIA) and works with both X11 and Wayland sessions.

** Inspiration & Design Philosophy
The environment variable handling and PATH injection approach is inspired by:
- [[https://github.com/d12frosted/homebrew-emacs-plus][homebrew-emacs-plus]] for macOS PATH injection

These approaches have been adapted for Linux AppImage compatibility with a focus on:
- *Respecting user environment:* Preserves system PATH and shell configurations (zsh, mise, asdf)
- *Clean integration:* No forced PATH injection that could conflict with user tools
- *Smart dispatching:* Intelligent handling of emacs/emacsclient based on invocation method

** Key Features
- *Version:* Builds Emacs 30.2 (configurable)
- *Performance:* Compiled with =-O2 -march=native=, Native Compilation (AOT), and pure GTK3 (PGTK)
- *Modern Features:* Includes Tree-sitter, JSON, SVG, and **Xwidgets with WebKitGTK** for embedded web browsing
- *Native Look & Feel:* Uses the host system's GTK theme and fonts (fixes common AppImage UI ugliness)
- *Smart Dispatcher:* Acts as =emacs= or =emacsclient= depending on how it is invoked
- *FUSE-Safe Building:* Build process runs entirely in userspace (extracts tools) to avoid Docker FUSE issues
- *Desktop Integration:* Automatic desktop entry creation with GearLever support for seamless desktop integration
- *Environment Compatibility:* Respects system PATH and shell configurations for better development workflow integration
- *Xwidgets Support:* Full WebKitGTK integration with rendering optimizations for stable web browsing within Emacs

* Requirements
- *Docker* (Recommended method)
- *OR* An Arch Linux system with =base-devel= installed

* Building (The Easy Way)
The recommended way to build is using the provided Docker wrapper. This handles all dependencies and FUSE permissions automatically.

#+begin_src sh
  # 1. Make scripts executable
  chmod +x docker-create-emacs-appimage.sh emacs-appimage-build.sh

  # 2. Run the builder
  ./docker-create-emacs-appimage.sh
#+end_src

** Build Options
You can pass arguments to the Docker wrapper:

#+begin_src sh
  # Build a specific version with a custom icon
  ./docker-create-emacs-appimage.sh \
      --version 31.0.50 \
      --icon "https://raw.githubusercontent.com/d12frosted/homebrew-emacs-plus/master/icons/modern-icon.png" \
      --output "Emacs-Next.AppImage"
#+end_src

* Usage

** Running Emacs Directly
The simplest way to run Emacs is to execute the AppImage directly:

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage
#+end_src

This will launch the Emacs GUI with all bundled dependencies.

** Running Emacs Client (emacsclient)
The AppImage contains a smart dispatcher that can act as either =emacs= or =emacsclient= depending on how it is invoked. Here are the recommended methods:

*** Method 1: Symlink (Recommended for Daily Use)
Create a symlink named ~emacsclient~ pointing to the AppImage. The AppImage detects its name and switches mode automatically.

#+begin_src sh
  # Create the link
  ln -s ./emacs-30.2-x86_64.AppImage emacsclient

  # Run it (connects to the socket)
  ./emacsclient -c -a ""
#+end_src

*** Method 2: Direct Argument
Pass the command as the first argument to the AppImage.

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage emacsclient -c -a ""
#+end_src

*** Method 3: Environment Variable
Set the =ARGV0= environment variable to control the mode.

#+begin_src sh
  ARGV0=emacsclient ./emacs-30.2-x86_64.AppImage -c -a ""
#+end_src

** Desktop Integration (Recommended)
For seamless desktop integration, use the provided desktop integration script:

#+begin_src sh
  # 1. Make the integration script executable
  chmod +x emacs-app-image-desktop-integration.sh

  # 2. Run the integration script
  ./emacs-app-image-desktop-integration.sh
#+end_src

This will:
- Create desktop entries for both "Emacs" and "EmacsClient"
- Extract and install the icon
- Set up proper permissions
- Support both Flatpak and standalone GearLever installations
- Configure WebKit environment variables for stable Xwidget rendering

To uninstall desktop integration:
#+begin_src sh
  ./emacs-app-image-desktop-integration.sh --uninstall
#+end_src

** Advanced Usage

*** Starting Emacs Daemon
To use the client-server model, first start the Emacs daemon:

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage --daemon
#+end_src

Then connect using emacsclient:

#+begin_src sh
  ./emacsclient -c -a ""
#+end_src

*** Using with System Tools
The AppRun script respects your system PATH and shell configurations. If you use tools like mise, asdf, or nvm, they should work seamlessly:

#+begin_src sh
  # Your system tools remain accessible
  ./emacs-30.2-x86_64.AppImage --version
  # Or with emacsclient
  ./emacsclient -e "(message "Hello World")"
#+end_src

*** Batch Mode Operations
You can use the AppImage for batch processing:

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage -Q -batch -f batch-byte-compile file.el
  ./emacs-30.2-x86_64.AppImage -Q -batch -l init.el -f some-function
#+end_src

* Technical Details

** How the Build Works
1. *Bootstrap:* Installs build dependencies (gcc, make, gtk3, webkit2gtk, etc.) via Pacman
2. *Compilation:* Compiles Emacs from source with ~--with-native-compilation=aot~ and ~--with-pgtk~
3. *Preparation:* Moves the ~emacs.pdmp~ (portable dumper) file to the correct architecture-specific directory
4. *Bundling:*
   - Uses *LinuxDeploy* to crawl the binary and bundle required shared libraries (libpng, librsvg, libxml2, etc.)
   - *Excludes* GTK/GDK/GLib libraries via ~--exclude-library~. This strategy avoids the "Frankenstein" library issue where bundled GTK libs cannot find host system schemas, ensuring native UI integration
5. *AppRun:* Injects a custom ~AppRun~ script that:
   - Sets up environment variables (~EMACSLOADPATH~, ~EMACSDATA~)
   - Handles the ~emacsclient~ dispatching based on invocation method
   - Preserves user PATH and environment configurations

** Smart Dispatcher Mechanism
The AppRun script implements an intelligent dispatcher that determines which binary to execute based on:

1. *Binary name:* If the symlink is named ~emacsclient~, it runs emacsclient
2. *First argument:* If the first argument is ~emacsclient~, ~ctags~, or ~etags~, it runs that command
3. *ARGV0 environment variable:* Can be set to override the detected binary name

This allows flexible usage patterns while maintaining compatibility with existing workflows.

** Environment Variable Handling
The AppRun script carefully manages environment variables to:

- *Prepend* Emacs binaries to PATH (so emacsclient works)
- *Preserve* user's original PATH (so system tools remain accessible)
- *Set* Emacs-specific variables (EMACSLOADPATH, EMACSDATA, etc.)
- *Respect* user shell configurations (zsh, bash, fish)

This approach prevents conflicts with user-installed tools while ensuring Emacs functionality.

* Troubleshooting

** FUSE Errors
If running on a system without FUSE, you can run the AppImage by extracting it:

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage --appimage-extract
  ./squashfs-root/AppRun
#+end_src

** Black Icon
If the icon appears black/blank, the build script automatically generates a fallback SVG. Ensure your desktop environment supports SVG icons.

** Environment Issues
The AppRun script respects your system PATH and shell configurations. If you use tools like mise or asdf, they should work seamlessly. If you encounter issues:

1. Check that your shell configuration files are being sourced
2. Verify that required tools are in your PATH
3. Try running with a clean environment to isolate the issue

** Desktop Integration
If desktop entries don't appear:
- Run the integration script with verbose output
- Check the applications directory at ~/.local/share/applications/
- Verify that you have write permissions to the applications directory

** Xwidget Issues
If you experience crashes or black screens with Xwidgets, see the Xwidgets Support section below.

* Xwidgets Support

** WebKitGTK Integration
This Emacs AppImage includes full WebKitGTK support for Xwidgets, enabling embedded web browsing directly within Emacs. The integration is optimized for stability and performance.

** Rendering Options
The desktop integration automatically configures WebKit rendering to avoid common issues:

- *Default:* WEBKIT_DISABLE_DMABUF_RENDERER=1 for GPU-accelerated rendering
- *Alternative:* WEBKIT_DISABLE_COMPOSITING_MODE=1 for maximum stability

** Configuration

The desktop integration automatically configures WebKit for stable Xwidget rendering. You can also set these environment variables manually:

#+begin_src sh
  # For GPU-accelerated rendering (recommended)
  export WEBKIT_DISABLE_DMABUF_RENDERER=1

  # For maximum stability (fallback)
  export WEBKIT_DISABLE_COMPOSITING_MODE=1
#+end_src

*** WebKit Rendering Options

WebKitGTK rendering can fail on Linux due to GPU driver issues, particularly with Wayland/NVIDIA combinations. Here are your options:

| Feature        | DISABLE_COMPOSITING_MODE    | DISABLE_DMABUF_RENDERER |
|----------------+-----------------------------+-------------------------|
| Page Rendering | CPU (Slow)                  | GPU (Fast)              |
| Video Playback | Choppy / High CPU usage     | Smooth                  |
| Crash Fix?     | Yes                         | Yes                     |
| Recommended?   | Only if the other one fails | Yes                     |

**Option 1: WEBKIT_DISABLE_DMABUF_RENDERER=1 (Recommended)**
- Keeps GPU acceleration enabled
- Disables only the problematic DMABuf rendering path
- Fixes 90% of Linux WebKit issues (NVIDIA flickering, Wayland crashes)
- Minimal performance impact

**Option 2: WEBKIT_DISABLE_COMPOSITING_MODE=1 (Fallback)**
- Disables all GPU acceleration
- Forces CPU-based software rendering
- Use only if DMABuf renderer option fails
- Significant performance impact on video and complex pages

*** Advanced: Setting Both Variables

You can set both variables simultaneously - it's safe and won't cause conflicts. However, this is redundant:

- Setting WEBKIT_DISABLE_COMPOSITING_MODE=1 already disables the DMABuf renderer
- The DMABUF variable becomes irrelevant when compositing is disabled
- You're effectively using the "Nuclear Option" (CPU rendering)

**Best Practice:** Try WEBKIT_DISABLE_DMABUF_RENDERER=1 first. Use WEBKIT_DISABLE_COMPOSITING_MODE=1 only if that fails.

* Desktop Integration Features

** [[https://github.com/mijorus/gearlever][GearLever Support]]
The desktop integration script creates two desktop entries:

1. *Emacs* - Main editor with full functionality
2. *EmacsClient* - Client mode for connecting to existing Emacs daemon

** Features
- *Automatic Icon Extraction:* Extracts icon from the AppImage with multiple fallback options
- *Multiple Desktop Entry Actions:* Includes actions for new windows and new instances
- *Environment Variables:* Sets appropriate environment variables for proper operation
- *Uninstall Support:* Clean removal of desktop entries and icons
- *Cross-Platform:* Works with both Flatpak and standalone GearLever installations
- *Xwidgets Optimization:* Includes WebKit environment variables for stable web rendering

** Desktop Entry Configuration
Both desktop entries include:
- Proper MIME type associations
- Startup notifications
- Keyboard shortcut support
- Multiple actions (new window, new instance, terminal client)
- WebKit rendering optimizations (WEBKIT_DISABLE_DMABUF_RENDERER=1 for GPU-accelerated rendering)

* Credits & Inspiration

This project builds upon the hard work of the community. Special thanks to:

- [[https://github.com/blahgeek/emacs-appimage/][blahgeek/emacs-appimage]]: For the inspiration on Docker-based Arch build workflows
- [[https://github.com/probonopd/Emacs.AppImage][probonopd/Emacs.AppImage]]: For pioneering the Emacs AppImage concepts and tooling
- [[https://github.com/d12frosted/homebrew-emacs-plus][homebrew-emacs-plus]]: For the PATH injection approach inspiration
