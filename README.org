#+TITLE: Emacs AppImage Builder (Arch Linux Universal)
#+AUTHOR: Emacs AppImage Builder
#+OPTIONS: toc:nil num:nil

* Overview
This project provides a robust, automated build system to create a portable *GNU Emacs AppImage* using an Arch Linux base.

It uses *LinuxDeploy* to bundle dependencies while specifically excluding system-dependent GUI toolkits (GTK) to ensure seamless integration with host themes, fonts, and input methods.

** Key Features
- *Version:* Builds Emacs 30.2 (configurable).
- *Performance:* Compiled with =-O3 -march=native=, Native Compilation (AOT), and pure GTK3 (PGTK).
- *Modern Features:* Includes Tree-sitter, JSON, SVG, and **Xwidgets with WebKitGTK** for embedded web browsing.
- *Native Look & Feel:* Uses the host system's GTK theme and fonts (fixes common AppImage UI ugliness).
- *Smart Dispatcher:* Acts as =emacs= or =emacsclient= depending on how it is invoked.
- *FUSE-Safe Building:* Build process runs entirely in userspace (extracts tools) to avoid Docker FUSE issues.
- *Desktop Integration:* Automatic desktop entry creation with GearLever support for seamless desktop integration.
- *Environment Compatibility:* Respects system PATH and shell configurations (zsh, mise, asdf) for better development workflow integration.
- *Xwidgets Support:* Full WebKitGTK integration with rendering optimizations for stable web browsing within Emacs.

* Requirements
- *Docker* (Recommended method)
- *OR* An Arch Linux system with =base-devel= installed.

* Building (The Easy Way)
The recommended way to build is using the provided Docker wrapper. This handles all dependencies and FUSE permissions automatically.

#+begin_src sh
  # 1. Make scripts executable
  chmod +x docker-create-emacs-appimage.sh emacs-appimage-build.sh

  # 2. Run the builder
  ./docker-create-emacs-appimage.sh
#+end_src

** Build Options
You can pass arguments to the Docker wrapper:

#+begin_src sh
  # Build a specific version with a custom icon
  ./docker-create-emacs-appimage.sh \
      --version 31.0.50 \
      --icon "https://raw.githubusercontent.com/d12frosted/homebrew-emacs-plus/master/icons/modern-icon.png" \
      --output "Emacs-Next.AppImage"
#+end_src

* Usage
** Running Emacs
Simply execute the AppImage:
#+begin_src sh
  ./emacs-30.2-x86_64.AppImage
#+end_src

** Running Emacs Client
The AppImage contains a smart dispatcher. You can use ~emacsclient~ features in two ways:

** Desktop Integration (Recommended)
For seamless desktop integration, use the provided desktop integration script:

#+begin_src sh
  # 1. Make the integration script executable
  chmod +x emacs-app-image-desktop-integration.sh

  # 2. Run the integration script
  ./emacs-app-image-desktop-integration.sh
#+end_src

This will:
- Create desktop entries for both "Emacs" and "EmacsClient"
- Extract and install the icon
- Set up proper permissions
- Support both Flatpak and standalone GearLever installations

To uninstall desktop integration:
#+begin_src sh
  ./emacs-app-image-desktop-integration.sh --uninstall
#+end_src

*** Method 1: Symlink (Recommended)
Create a symlink named ~emacsclient~ pointing to the AppImage. The AppImage detects its name and switches mode automatically.

#+begin_src sh
  # Create the link
  ln -s ./emacs-30.2-x86_64.AppImage emacsclient

  # Run it (connects to the socket)
  ./emacsclient -c -a ""
#+end_src

*** Method 2: Direct Argument
Pass the command as the first argument to the AppImage.

#+begin_src sh
  ./emacs-30.2-x86_64.AppImage emacsclient -c -a ""
#+end_src

* Technical Details
** How the Build Works
1. *Bootstrap:* Installs build dependencies (gcc, make, gtk3, webkit2gtk, etc.) via Pacman.
2. *Compilation:* Compiles Emacs from source with ~--with-native-compilation=aot~ and ~--with-pgtk~.
3. *Preparation:* Moves the ~emacs.pdmp~ (portable dumper) file to the correct architecture-specific directory.
4. *Bundling:*
   - Uses *LinuxDeploy* to crawl the binary and bundle required shared libraries (libpng, librsvg, libxml2, etc.).
   - *Excludes* GTK/GDK/GLib libraries via ~--exclude-library~. This strategy avoids the "Frankenstein" library issue where bundled GTK libs cannot find host system schemas, ensuring native UI integration.
5. *AppRun:* Injects a custom ~AppRun~ script that sets up environment variables (~EMACSLOADPATH~, ~EMACSDATA~) and handles the ~emacsclient~ dispatching.

** Troubleshooting
- *FUSE Errors:* If running on a system without FUSE, you can run the AppImage by extracting it:
  #+begin_src sh
    ./emacs-30.2-x86_64.AppImage --appimage-extract
    ./squashfs-root/AppRun
  #+end_src
- *Black Icon:* If the icon appears black/blank, the build script automatically generates a fallback SVG. Ensure your desktop environment supports SVG icons.
- *Environment Issues:* The AppRun script respects your system PATH and shell configurations. If you use tools like mise or asdf, they should work seamlessly.
- *Desktop Integration:* If desktop entries don't appear, run the integration script with verbose output or check the applications directory at ~/.local/share/applications/

*

* Xwidgets Support
** WebKitGTK Integration
This Emacs AppImage includes full WebKitGTK support for Xwidgets, enabling embedded web browsing directly within Emacs.

** Rendering Options
The desktop integration automatically configures WebKit rendering to avoid common issues:

- *Default:* WEBKIT_DISABLE_DMABUF_RENDERER=1 for GPU-accelerated rendering
- *Alternative:* Uses WEBKIT_DISABLE_COMPOSITING_MODE=1 for maximum stability

** Configuration
Both desktop entries include the appropriate WebKit environment variables to ensure stable web browsing experience.

*** The Technical Difficulty with xwidget

=WebKitGTK= (used by Emacs xwidgets for web rendering) is attempting to initialize hardware-accelerated OpenGL rendering, but your current Wayland/GDK backend cannot provide a valid GL context.
Users experience crashes or black screen when using =xwidgets= due to this. These are 2 options to fix that -

1. =WEBKIT_DISABLE_COMPOSITING_MODE=1= (The "Nuclear" Option)

    What happens: The browser stops using the GPU completely. The CPU has to calculate every pixel of the website, draw it, and then hand it to Emacs.

    Result: High stability, but Slow.

    Feel: Scrolling large pages might feel sluggish, and watching videos inside Emacs will consume 100% of a CPU core.

2. =WEBKIT_DISABLE_DMABUF_RENDERER=1= (The "Surgical" Option)

    What happens: The browser still uses your AMD GPU to render the website quickly.

    The Change: Normally, the browser tries to hand that finished image directly to Emacs via a fast hardware shortcut (DMABuf). This shortcut is what is crashing. By setting this flag, you force the browser to take a slightly slower route (copying the image to system memory first) to hand it over to Emacs.

    Result: Fast. The GPU still does the hard work; the only "slow" part is the hand-off, which is negligible on modern AMD cards.

    | Feature        | DISABLE_COMPOSITING_MODE    | DISABLE_DMABUF_RENDERER |
    |----------------+-----------------------------+-------------------------|
    | Page Rendering | CPU (Slow)                  | GPU (Fast)              |
    | Video Playback | Choppy / High CPU usage     | Smooth                  |
    | Crash Fix?     | Yes                         | Yes                     |
    | Recommended?   | Only if the other one fails | Yes                     |

Note: The desktop integration script automatically includes the appropriate WebKit environment variables in the desktop entries.

*** Advanced Configuration

Yes, you can absolutely set both variables simultaneously. It is safe to do so, and it will not cause a crash or conflict.

However, it is helpful to understand that doing so is effectively **redundant**.

###### Why it is redundant

Think of these variables as a "Hammer" and a "Screwdriver":

1. **`WEBKIT_DISABLE_COMPOSITING_MODE=1` (The Hammer):**
   * This completely disables **Accelerated Compositing**.
   * It forces WebKit to render everything on the CPU (software rendering).
   * If you set this, the DMABuf renderer (which is a hardware acceleration feature) is effectively turned off anyway because the entire acceleration pipeline is disabled.

2. **`WEBKIT_DISABLE_DMABUF_RENDERER=1` (The Screwdriver):**
   * This is a more precise fix. It keeps hardware acceleration **ON** but disables the specific "Direct Memory Access Buffer" (DMABuf) rendering method.
   * This is currently the standard fix for NVIDIA/Wayland flickering issues because it forces WebKit to fall back to an older, more stable rendering path while still trying to be fast.

###### The Recommendation

If you set **both**, you are just hitting the "Nuclear Option" (Software Rendering). The `DMABUF` variable becomes irrelevant because you have already killed the system that would have used it.

**My advice:**

1. **Try just `WEBKIT_DISABLE_DMABUF_RENDERER=1` first.**
   * This fixes 90% of modern Linux WebKit glitches (white screens, flickering on NVIDIA).
   * It preserves better performance than disabling compositing entirely.

2. **Use `WEBKIT_DISABLE_COMPOSITING_MODE=1` only if the first one fails.**
   * This is the fallback if your GPU drivers are completely broken with WebKit.

* Desktop Integration Features
** GearLever Support
The desktop integration script creates two desktop entries:

1. *Emacs* - Main editor with full functionality
2. *EmacsClient* - Client mode for connecting to existing Emacs daemon

** Features
- *Automatic Icon Extraction:* Extracts icon from the AppImage with multiple fallback options
- *Multiple Desktop Entry Actions:* Includes actions for new windows and new instances
- *Environment Variables:* Sets appropriate environment variables for proper operation
- *Uninstall Support:* Clean removal of desktop entries and icons
- *Cross-Platform:* Works with both Flatpak and standalone GearLever installations
- *Xwidgets Optimization:* Includes WebKit environment variables for stable web rendering

** Desktop Entry Configuration
Both desktop entries include:
- Proper MIME type associations
- Startup notifications
- Keyboard shortcut support
- Multiple actions (new window, new instance, terminal client)
- WebKit rendering optimizations (WEBKIT_DISABLE_DMABUF_RENDERER=1 for GPU-accelerated rendering)

* Credits & Inspiration
This project builds upon the hard work of the community. Special thanks to:

- [[https://github.com/blahgeek/emacs-appimage/][blahgeek/emacs-appimage]]: For the inspiration on Docker-based Arch build workflows.
- [[https://github.com/probonopd/Emacs.AppImage][probonopd/Emacs.AppImage]]: For pioneering the Emacs AppImage concepts and tooling.
